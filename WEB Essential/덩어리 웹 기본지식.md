## 비 연결성(connectionless)

- 클라이언트가 여러 개 있는 상황에서 TCP/IP 연결을 한 상태에서 모두가 연결을 유지하고 있다면, 놀고 있는 클라이언트와의 연결을 유지하기 위해 서버의  자원이 소모되어야한다.
- 요청과 응답 한 사이클이 끝나면 연결을 끊어버리는 비연결성이 있기에, 한시간동안 수천 명의 접속자가 있다고 해도 초 단위 이하의 빠른 응답 후, 연결 끊기를 통해 자원을 잘 유지할수 있다.

 

     

## 무상태(stateless)

  

- 각각의 요청에 독립적으로 반응해주면 되고 저장을 할 필요가 없다.
- 무상태로 서버를 설계하면 서버가 부족할때 얼마든지 양을 늘릴 수 있다. // a서버에서 b서버로 대체 할수도 있고 연장할수도 있다.
- 개발자들이 대응을 어려워하는 경우가 한번에 대용량 트래픽이 몰리는 것이다.
- 예를 들어 선착순 이벤트 같은 것이 있다.

## HTTP 메시지

- 메시지의 구조로는 1. 시작라인 2. 헤더 3. 공백라인 그리고 메시지 바디가 있다.
- 공백 라인은 무조건 들어가 있어야 한다.
- 시작 라인   - 요청일 경우에는 GET/search?q=name ... http 1.1 의 순서로 쓰인다.
- method path http version  이 구조로 시작 라인이 구성되어 있다.
- '/'를 절대경로라고 한다.

    응답 메시지 - 200 ok 400 클라이언트 오류 500 서버 오류

- http 헤더의 용도 - http 전송에 필요한 모든 부가정도 메시지 바디 빼고 필요한 메타정보가 모두 다 들어가있다.
- 메시지 바디 : 실제 전송할 데이터가 포함되어있다. 문서 이미지 영상 json등등
- http 1.1에 모든 중요한 것들이 다 들어있고 2,3은 단순한 성능 개선이므로 공부는 http1.1을 해야한다.

---

## 네트워크 통신의 순서

1. 애플리케이션에서 메시지를 소켓 라이브러리를 통해 os로 보낸다.
2. os에서 전송계층인 tcp가 메시지를 한번 감싼다. - tcp에는 출발/목적지 port 정보 , 검증 등등의 정보가 들어가 있다.

     - tcp는 3 handshake 방식을 사용한다. 

    - 3 handshake는 클라이언트가 서버로 syc를 보내면 서버에서 syc와 ack를 보내고 클라이언트가 다시 ack를 보내는 과정을 거친다. 

   - 패킷이 도착하는 순서가 보장되고 데이터 전송이 보장된다. 

3. TCP가 감싼것을 인터넷 계층에서 IP가 다시 한번 감싼다. IP에는 출발/목적지의 IP정보가 들어있다. 

4. TCP는 IP의 단점을 보완하기 위해 나온 것이다. 

---

## 😀 HTTP URI 설계

### 좋은 URI의 설계법 : 리소스 식별을 고려 , 즉 리소스의 의미를 담아야함

리소스란?  미네랄을 캐는 행위가 리소스가 아니라 미네랄 자체가 리소스이다. 

url는 리소스만 식별!!!

리소스의 행위는 식별하면 안된다. 

리소스는 명사 행위는 동사 

예를 들어 member를 다뤄야 할때 , uri에는 members만 적고 구체적인 행위는 http 메서드를 통해서 해결해야 한다. 

- GET : 리소스 조회

 -  패스에 있는 자원을 달라! 

- GET에서도 메세지 바디를 사용해서 데이터를 전달을 할수는 있지만, 보통 쿼리 파라미터를 통해 데이터를 보낸다.
- EX> GET/members/100 이라고 적혀있다면 members 의 100번 유저를 달라는 것이다!!

- POST : 요청 데이터 처리 , 주로 등록에 사용  예를 들어 form에서 입력값을 받아서 서버로 넘겨주고 postmapping을 통해서 받는게 있다.
- 데이터를 서버에 보내면 서버에서는 신규 등록하고 새로운 uri를 추가한다.
- 차후에 응답 메시지를 보내줄때는 보통 201 create를 보내고 자원이 생성된 경로를 보내준다.
- 정리 : 1. 새 리소스 생성(등록)
- 2. ** 요청 데이터 처리 → 프로세스 처리
- 결제완료 → 배달시작 버튼 누름 → 그걸 post로 보내야 한다. 프로세스를 진행시키는 기능을 한다.
- 동사의 uri가 나올 수도 있다. 명사로 다 하면 최선이지만 실무에서는 힘들때도 있다. 그런걸 컨트롤uri가 있다.
- 다른 메서드로 처리하기 애매한 경우 json으로 조회하는 데이터를 넘겨야하는데 쿼리파라미터에는 담아서 넘기기 좀 그래 → get메서드의 메시지바디는 허용이 안되기 때문에 post를 써야함
- 내부에 데이터를 담아 보내는 모든걸 할수 있는 post 그러나 caching 기능은 get에서만 되기 때문에 조회는 왠만하면 get으로 하자.

- PUT : 파일을 폴더에 넣는 개념과 동일 없으면 그냥 넣고 있으면 덮어씌움
- put은 uri의 전체 경로를 다 명시해줘야 한다. 정확한 자리에 넣어주는 것이다
- 리소스를 완전히! 대체한다.

- PATCH : 리소스 부분변경 예를 들어 이름을 바꾸는 등의 일부 필드를 바꿀때 사용

  - PUT이라는건 기존 데이터를 완전 갈아엎어 버리는 것이다 그러므로 부분적 변경을 위한 메서드가 필요하다. 그래서 나온게 PATCH

  PATCH가 안되는 서버들도 있다. 그럴때는 POST를 쓰면 된다!! 

- DELETE : 리소스 삭제

<안전> 리소스가 변화하는지를 나타낸 것이다.

<멱등> 몇번을 호출하든 결과가 똑같다. 

- 멱등하다면 자동으로 메서드를 다시 호출하는 자동 복구 메커니즘을 사용할수 있다!
- 외부 요인에 의해서 값이 변경된거는 고려 안해 !

<캐시가능> 응답결과를 캐시에서 사용할수 있는가?

GET과 HEAD를 캐시로 사용 URL을 키로 잡고 캐시로 사용한다. 실무에서는 GET만 캐시를 사용한다!! 

클라이언트에서 서버로 데이터를 전송하는 방법 

1. 쿼리 파라미터 (GET) 정렬 필터나 검색할때 사용 
2. 메시지 바디 

1. 정적 데이터(이미지, 정적 텍스트 문서) 쿼리 파라미터 없이 리소스 경로만으로 탐색 가능 
2. 동적 데이터 주로 검색을 하거나 게시판 목록에서 정렬할때 , 필터 
3. HTML Form 데이터 전송 

  

```java
<form action="/hello" method = "post"> // action은 post를 보내고자 하는 경로를 나타낸다. method는 post라고 방식을 정해주면 된다.
<input type = "text" name="username"> // input 안에 name 속성을 넣어줘야한다. 이 속성을 key로 해서 요청 메시지 바디에 name=입력값 형태로 데이터를 실어준다. 
<button type = "submit">전송</button>
```

만약 HTML Form에서 file을 같이 전송해야한다면?

```java
<form action="/hello" method = "post" enctype = "multipart/form-data">   // file이 아니더라도 여러 형태의 데이터를 보내야 할때는 enctype= "multipart/form-data" 를 사용한다. 주로 바이너리 데이터 전송
```

form은 GET과 POST만 지원한다. 

---

### 4. HTTP API 데이터 전송

- 서버 TO 서버
- 앱 클라이언트
- 웹 클라이언트( HTML에서 form 전송 대신 자바스크립트를 통한 통신에 사용 (AJAX)
- React Vue.js 같은 웹 클라이언트들과 API 통신

  content-type = application/json

옛날에는 xml을 주로 썻지만 복잡해서 이제는 json으로 넘어왔다.

---

## HTTP API 설계 예시

회원 목록 /members get

회원 등록 /members (컬렉션)(회원을 관리하는 uri) post

---

회원 조회 /members/{100} get

회원 삭제 /members/{100} delete

회원 수정 /members/{id}

- 보통의 수정에는 patch를 써야한다. put은 통째로 갈아엎는 것이기 때문에 바꿔야 하는 데이터의 양이 많으면 실수로 값이 사라질수도 있다. 그래서 보통은 patch를 쓴다. 그치만 게시판의 수정 같은 경우에는 글을 수정하면 통째로 다시 서버로 보내기 때문에 put을 사용해도 된다.

중요!! POST는 해당 리소스의 URI로 보내는게 아니라 컬렉션으로 보내는 것이다. 등록한 리소스의 식별자는 서버가 만든다. 그다음 리턴해줌 

파일 업로드에는 PUT이 딱 적절하다. 

클라이언트가 직접 리소스의 URI를 지정하는것은 스토어 방식이다.

스토어는 클라이언트가 관리하는 리소스 저장소이다. 

정리해보면 , post는 겹치면 안되는 정보, PUT은 겹쳐도 되는 정보에 사용하는게 맞다고 본다. 

대부분은 컬렉션을 사용한다!! 

- HTML 폼에서는 GET 과 POST만 이용 가능하다. 그러므로 컨트롤 URI인 /new /edit /delete를 쓸수밖에 없다.

http 메서드로 해결하기 어려운 경우에 컨트롤 uri를 쓰자 동사로 표현해야함!! 

참고하면 좋은 URI 설계 개념 

- 리소스로 URI를 설계해야함!
- 컨트롤 URI (동사)로 쓰기!!
- 리소스로만 만든 URI 안에서 GET DELETE POST PUT 등으로 해결한다. 안되면 컨트롤 URI 쓰자

😃표를 참고해보자 

[HTTP 메서드를 사용한 작업](https://www.notion.so/105d1ec14e4a4e3eaff79b83d51c9e25)

---

## HTTP 상태코드

- 3XX 요청을 완료하려면 추가 행동이 필요한것 (리다이렉션)
- 리다이렉트란 : 웹 브라우져는 300대 응답에 LOCATION 헤더가 있으면 그 위치로 자동 이동한다.

    301 코드 : 예를 들어서 예전 URL이 /naver 이였는데 /nav-ev 로 변경됬을때 기존 사용자가 /naver로 타고 들어오면 301 리다이렉션을 해준다. 

200 OK 는 GET이 정상적으로 실행됬을때 나온다.

201 CREATED는 POST로 요청했을때 새로운 리소스가 잘 나오면 나온다. 

204 NO CONTENT 웹 문서 편집기에서 SAVE 버튼 

보통 200이나 201 까지만 쓴다. 실무에서는 기준을 잘 정해서 써야한다. 

---

## HTTP 헤더

표현 헤더  : 표현 데이터(메시지 바디 안에 들어가있다)을 해석할수 있는 정보가 들어있다. 

메시지 본문 : 페이로드 라고도 한다. 

즉, 페이로드(메시지본문)안에 표현 데이터를 실어서 넘기고 , 그 표현 데이터에 대한 부가 정보를 표현 헤더라고 한다. 두개를 합치면 표현 이라고 한다.

회원이라는 리소스의 실제 데이터가 전달이 될때는 html로 표현될수도 있고 json으로 표현될수도 있다. 

회원 리소스를 html이나 json으로 전송할지 표현하는것.   ** 리소스는 매우 추상적인 개념이다! db에 있을수도 있고 바이트코드로 있을수도 있다. 

그래서 클라이언트와 서버가 서로 주고받을때는 서로가 이해할 수 있는 형태로 표현해야 한다. 그 형태로는 html json xml등이 있다. 

표현 헤더 : content-type 표현 데이터의 형식, 즉 어떤 표현을 선택했는지를 명시한다. 

content encoding은 표현 데이터의 압축 방식 , 최근에는 gzip을 많이 쓴다. identity는 압축 안한다는 것이다. 

---

## 콘텐츠 협상

- 협상 헤더는 요청시에만 사용한다.

   - 서버 측에서 클라이언트가 요구한걸 가지고 있으면 그걸로 나간다. 그러나 실무에서는 복잡하기 때문에 내가 원하는게 없다면 다른걸 우선순위를 둬서 선택해야 할수도 있다. 

   - 그럴때는 예시로 ko-KR, ko;q:0.9 , en;q:0.8 등등으로 우선순위를 둘 수 있다. 

   - 구체적인 것이 우선한다. text/*  text/plain text/plain;format=flowed,  중에서는 3번째 - 2번째 - 1번째 순으로 우선순위가 높다. 

클라이언트는 서버에서 어떤 것들을 제공하는지 미리 알고 자신이 원하는 요소를 우선순위로 정해서 요청해야 한다. 

## 전송 방식

- 단순 전송 : http 메시지를 보낼때 표현 데이터에 대한 content-length 만 같이 실어서 보내는것
- 압축 전송 : 단순 전송에 압축을 추가해서 보내는것
- 분할 전송 : transfer encoding : chunked를 추가해서 보내는것 서버에서 첫번째 보내면 클라이언트가 첫번째꺼 받는다 그다음에 두번째꺼를 보낸다.
- 용량이 클때 단순전송은 늦게 전시가 되지만 분할 전송은 보내는 대로 표시 가능 ** 분할전송에서는 content-length 넣으면 안됨. 예상이 안될뿐더러 각각의 길이가 있다.
- 범위 전송 : 구간을 쪼개서 보낼 수 있다. 1001~2000까지의 방식이다.

## 일반 헤더

- Referer : 이전 웹페이지 주소 a-b 이동할때 b를 요청할때 referer : a를 포함해서 요청한다. 유입경로를 분석할때 사용 요청에서 사용
- user-agent : 클라이언트의 애플리케이션 정보 (웹 브라우져 정보) 어떤 종류의 브라우저에서 문제가 발생하는지 파악 가능
- server 요청을 처리하는 origin 서버(내 요청을 처리해주는 마지막 서버)의 소프트웨어 정보

  data 메시지가 발생한 시간 

## 특별한 정보 담은 헤더

- host 헤더 : 요청에서 사용 **필수 헤더이다**
- 하나의 서버가 여러 도메인을 처리해야 할때
- 하나의 ip주소에 여러 도메인이 적용되어 있을때

 — 서버에서 받아서 가상 호스팅을 통해 원하는 어플리케이션으로 보낼 수 있다.

- Allow 허용가능한 http 메서드 허용하는 메서드를 응답에 포함해서 내려주는 것이다.
- Retry-After 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
- authenticate : 인증이 되지 않았을때 401에러를 내면서 정보를 실어야 한다. 인증을 하기 위해 필요한 정보를 헤더에 실어서 보낸다.

## 쿠키 (중요!!)

- set-cookie : 서버에서 클라이언트로 쿠키 전달
- cookie 클라이언트는 받은 쿠키를 저장하고 http 요청때 같이 보냄
- http는 기본적으로 무상태이다. 서버와 클라이언트의 요청 응답이 끝나면 연결을 끊어버린다. 그러므로 그 클라이언트의 이전 요청을 기억하지 못한다, 상태를 유지하지 않는다.
- 대안은 요청에 개인정보를 다 실어서 넘기는것 → 현실적으로 불가능
- 그래서 생겨난게 쿠키이다 .일단 로그인을 성공하면 해당 로그인 정보를 쿠키로 말아서 응답에 실어서 보낸다. 쿠키는 웹 브라우저의 쿠키저장소에 저장이 된다. 이후 클라리언트의 모든 요청에 쿠키를 포함한다.
- 주로 로그인 세션 관리에 쓰인다! 그런데 id = 홍길동 처럼 온전한 정보로 보내지 않는다. 따로 세션 아이디를 만들어서 클라이언트에게 보내준다.
- 항상 서버에 보내져야 하기 때문에 트래픽이 발생할수 있으므로 최소화 시켜야 한다.
- 서버에 보내지 않고 웹브라우져가 보관하고 싶으면 웹스토리지 사용하면 됨.

— 쿠키의 생명주기 

세션 쿠키 : 간단히 브라우져 종료하면 쿠키 다 날라감 → 로그인 다시 해야 함 

영속 쿠키 : 만료기간 까지는 계속 유지된다. 

도메인을 지정해주면 : [example.org](http://example.org) 기준 도메인과 해당 도메인을 포함한 서브 도메인에 모두 쿠키가 보내진다. 

도메인 자체를 지정 안해주면 해당 도메인만 쿠키 접근 가능하다 

경로를 지정해주면 도메인의 하위 경로에 보낼수 있다. 

secure 쿠키는 http https 구분않고 전송하지만 secure적용해주면 https로만 보낸다. 

---

## 캐시

cache-control : max-age= 60 최대 60초 동안 웹 브라우저에서 캐시를 저장 → 다음번에 똑같은 이미지를 찾는다면 캐시로 접근 , 유효시간을 경과했는지 보고 경과 안했으면 캐시에서 가져온다. 

만약에 유효기간이 경과했다면 다시 네트워크에 접속해서 다운로드 받고 cache-control을 통해 유효시간을 다시 받아야 한다. 

그런데 이미지가 전혀 변화하지 않았는데 유효기간이 지났다고 똑같은걸 다운받는건 비효율적인것 같아. 이를 해결해보자 

클라이언트가 서버로 다시 요청했을때 1. 서버의 데이터가 변경되었을수도 있고 2 데이터가 그대로 일수도 있다. 

순서 : 처음에 요청을 보냄 → 서버에서 요쳥한 자료와 cache-control값과 최종수정일을 보냄 캐시로 들어감 → 다음에 다시 요청할때 브라우저 캐시로 가서 만료기간 지났는지 확인 → 만료기간을 지났지만 최종수정일이 있다면 검증헤더(last modified)에 (if modified since) 실어서 요청을 보냄 → 해당 날짜와 서버상 이미지의 최종수정 날짜가 같다면 → http 응답으로 304 not modified로 간다. → 브라우저는 헤더 가지고 와서 브라우저 캐시 갱신 → 캐시에서 자료 다시 가져와서 사용한다. 즉, 두번째로 요청할때는 용량이 작은 헤더만 다운 받으면 된다. 

- last modified 는 검증헤더 캐시데이터와 서버 데이터가 같은지 검증하는 데이터 etag도 있다.
- if modified since는 조건부 헤더이다

   → 1초 미만 단위로 캐시 조정 불가능 왜냐하면 날짜기반의 로직을 사용하고 최소 단위가 1초이다. ** 변경된 날짜만을 가지고 판단하기 때문에 만약에 자료가 바뀌었다가 원자료로 돌아와있으면 다시 다운받아야함    

서버에서 완전하게 캐시 로직을 컨트롤하게 해준다. 클라이언트는 캐시 메커니즘을 모름 

etag 활용법 → 해당 데이터에 대한 해시 값을 만들어서 http헤더에 실어서 보낸다. 나중에 수정을 해야할때 해당 etag값과 지급 서버의 etag 값이 같다면 헤더만 다시 보내줘서 캐시 브라우저를 갱신한다. 

캐시 관련 용어 정리 

- cache control : max-age 캐시 유효 기간 보통 길게 잡는다 , no-cache 데이터는 캐시해도 되지만 , 항상 원 서버에 검증하고 사용 (조건부 요청을 해서 항상 서버에 검증하고 사용)  유효기간이 지나지 않았어도no-store 데이터에 민감한 정보있어서 하드디스크에 저장하면 안됨 메모리에서 간단간단히 사용 .   no-cache는 저장가능 no-store는 아예 저장도 불가능

expires : max-age와 같은 기능 캐시 만료일을 정확한 날짜로 표시 max-age랑 같이 사용되면 무시된다. 

---

## 프록시 캐시

웹 브라우저는 프록시 캐시 서버를 통해 원서버를 간다. 

프록시가 있어서 유튜브를 빨리 볼수 있는 것이다. 사람들이 많이 보는 컨텐츠는 보통 cdn 서비스 프록시 캐시 서버를 통해 제공된다. 

공용으로 사용하는 캐시 서버이다 

일반 클라이언트가 사용하는 캐시는 프라이빗 캐시라고 한다. 

cachecontrol : public  public 캐시에 저장되도딤 이미지 등등

cachecontrol : private 나 private에만 적용된다 나만의 아이디 개인정보 

age : 원 서버에서 출발한 데이터가 public 캐시 서버에 머무는 시간 

최초에 요청하는 클라이언트는 캐시를 못씀 원서버에서 캐시가 들어오고나면 다음 유저들은 마음껏 쓸수 있다. 

---

캐시 무효화 cache-control : no-cache , no-store, must-revalidate 예를 들어 현재 사용자의 통장잔고는 계속해서 캐시가 되기때문에 캐시가 안되는게 낫다 

** no-cache로 보냈을때 프록시서버에서 원서버로 네트워크 단절이 되었을때 200ok, 프록시캐시에 있는 과거데이터로 올수도 있다. must-revalidate는 네트워크 단절하면 무조건 오류코드 보낸다.
