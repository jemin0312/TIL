## 엔티티 매니저

- 고객 요청이 들어오면 먼저 앤티티매니져 팩토리에서 엔티티메니져를 만들어낸다. 엔티티매니져는 내부적으로 커낵션풀을 거쳐서 db에 접근한다.
- entitymanager.persist(entity)를 진행하면 db에 저장이 되는것이 아니라 entity를 영속화 시키는것, 즉 영속성컨텍스트 안에 저장하는 것이다. 트랜잭션을 커밋해야 db로 날라간다.
- 객체만 생성시켜 놓은 상태는 비영속 상태 , 만약 persist하면 영속 상태가 된다.
- ** persist는 영속성 컨텍스트에 올리는것, detach는 영속성 컨텍스트에서 분리하는 것, remove는 db에서 지우는것

- 1차 캐시 가능 - 하나의 트랜잭션 내부에서 엔티티를 persist하고 바로 find를 하면 먼저 영속성 컨텍스트 안의 1차 캐시에서 뒤진다. 만약 1차 캐시에 없는 엔티티를 요구하면 db로 접근해서 해당 엔티티를 빼와
- 1차 캐시에 저장하고 반환한다.

### 쓰기지연 sql 저장소

- 영속성 컨텍스트 내부에는 1차 캐시와 쓰기지연sql저장소가 있다. 1. persist를 하면 1차 캐시에 엔티티가 잠시 저장된다. 그러면서 영속성 컨텍스트는 해당 엔티티를 분석해서 쓰기지연sql에 sql쿼리를 만들어놓는다. 사용자가 transaction 커밋을 날리면 영속성 컨텍스트 내부에서 flush가 일어나며 sql쿼리들이 모두 db로 날라간다. 그 뒤에 실제 commit이 일어난다.

*** jpa는 동적으로 객체를 생성해내기 때문에 기본 생성자가 엔티티 내부에 꼭 있어야 한다. 

- persist할때마다 쿼리를 날리면 최적화할 여지가 없다.
- 변경감지(더티 체킹)  : 1. 처음에 find를 통해서 1차 캐시에 등록이 되었을때 초기 상태에 대한 스냅샷을 떠놓는다. 만약 중간에 값이 변경되서 스냅샷과 엔티티가 다르다면, flush()가 호출될때 엔티티와 스냅샷
- 이 같은지 일일이 체크하고 만약 다르다면 업데이트 쿼리를 쓰기지연 sql 저장소에 등록한다. 그리고 바로 다 flush 시켜버린다.
- ** find로 찾아와서 setname등으로 변경만 하면 실제 db내부에 값이 바뀐다!!

## Flush

- 플러시를 하게 되면 1. 변경 감지가 일어난다 2. 변경사항이 있는 경우 쓰기지연저장소에 업데이트 쿼리가 쌓인다. 담아놓은 쿼리들을 모두 데이터베이스로 보낸다. 그 이후에 커밋이 일어난다.
- 중요한건 플러시가 된다고 해서 1차 캐시가 지워지거나 하는건 아니다! 오직 쓰기 지연 저장소만 비워진다. JPQL을 쏠때는 무조건 먼저 플러쉬가 일어난다. 왜냐하면 JPQL은 바로 데이터베이스를 대상으로 쓰기 때문에 잘못하면 데이터베이스에 아직 엔티티가 없을수도 있기 때문이다. ** 플러쉬는 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 시키는 것이다!!

## 준영속상태

- em.detach(entity)를 쓰면 그 엔티티는 더이상 영속성 컨텍스트의 관리를 받지 못한다. 즉 기능들을 사용할수 없게 된다. 더티 체킹 후 수정 쿼리 날리는 등의 기능을 말한다.
- em.clear()를 쓰면 영속성 컨텍스트가 싹다 비워진다 (1차 캐시에 아무것도 안 남는다)
